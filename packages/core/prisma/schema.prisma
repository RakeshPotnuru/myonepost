// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

generator json {
  provider = "prisma-json-types-generator"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  email             String    @unique
  username          String    @unique @db.VarChar(30)
  displayName       String?   @map("display_name") @db.VarChar(30)
  bio               String?   @db.VarChar(150)
  avatarUrl         String?   @map("avatar_url")
  url               String?
  nextPostAllowedAt DateTime? @map("next_post_allowed_at") @db.Timestamptz(3)
  isPrivate         Boolean   @default(false) @map("is_private")
  subscriberCount   Int       @default(0) @map("subscriber_count")
  subscriptionCount Int       @default(0) @map("subscription_count")

  subscribers    Subscriber[]   @relation("UserSubscribers")
  subscribedTo   Subscriber[]   @relation("UserSubscribedTo")
  post           Post?
  likes          PostLike[]
  comments       Comment[]
  commentLikes   CommentLike[]
  notifications  Notification[]
  reportsMade    Report[]       @relation("ReportMadeBy")
  reportsAgainst Report[]       @relation("ReportAgainst")

  @@map("users")
}

model Subscriber {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  userId         String @map("user_id") @db.Uuid
  user           User   @relation("UserSubscribers", fields: [userId], references: [id], onDelete: Cascade)
  subscribedToId String @map("subscribed_to_id") @db.Uuid
  subscribedTo   User   @relation("UserSubscribedTo", fields: [subscribedToId], references: [id], onDelete: Cascade)

  @@unique([userId, subscribedToId])
  @@map("subscribers")
}

model Post {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  postType     PostType   @map("post_type")
  text         String?    @db.VarChar(4000)
  mediaUrl     String?    @map("media_url")
  /// [MediaDataType]
  mediaData    Json?      @map("media_data") @db.JsonB
  mediaCaption String?    @map("media_caption") @db.VarChar(150)
  commentCount Int        @default(0) @map("comment_count")
  likeCount    Int        @default(0) @map("like_count")
  status       PostStatus @default(PENDING)

  userId    String     @unique @map("user_id") @db.Uuid
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes     PostLike[]
  comments  Comment[]
  reports   Report[]
  postScore PostScore?

  @@map("posts")
}

enum PostType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
}

enum PostStatus {
  PENDING // draft/processing
  APPROVED // posted
  FLAGGED // in review
  REJECTED // not approved
}

model PostLike {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId String @map("post_id") @db.Uuid
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("post_likes")
}

model Comment {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  text      String @db.VarChar(280)
  likeCount Int    @default(0) @map("like_count")

  userId  String        @map("user_id") @db.Uuid
  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId  String        @map("post_id") @db.Uuid
  post    Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  likes   CommentLike[]
  reports Report[]

  @@unique([userId, postId])
  @@map("comments")
}

model CommentLike {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  userId    String  @map("user_id") @db.Uuid
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  commentId String  @map("comment_id") @db.Uuid
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@map("comment_likes")
}

model Notification {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  type    NotificationType
  isRead  Boolean          @default(false) @map("is_read")
  content String           @db.VarChar(280)

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

enum NotificationType {
  NEW_POST_LIKE
  NEW_COMMENT_LIKE
  NEW_COMMENT
  NEW_SUBSCRIBER
}

model Report {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  reason      ReportReason
  description String?
  reportType  ReportType   @map("report_type")
  status      ReportStatus @default(PENDING)

  reportedById String @map("reported_by_id") @db.Uuid
  reportedBy   User   @relation("ReportMadeBy", fields: [reportedById], references: [id], onDelete: Cascade)

  reportedUserId String @map("reported_user_id") @db.Uuid
  reportedUser   User   @relation("ReportAgainst", fields: [reportedUserId], references: [id], onDelete: Cascade)

  postId String? @map("post_id") @db.Uuid
  post   Post?   @relation(fields: [postId], references: [userId], onDelete: Cascade)

  commentId String?  @map("comment_id") @db.Uuid
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@map("reports")
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum ReportType {
  USER
  POST
  COMMENT
}

enum ReportReason {
  INAPPROPRIATE_CONTENT // Offensive or inappropriate language or visuals
  HARASSMENT // Bullying or harassment towards a user
  SPAM // Unwanted, irrelevant, or repetitive content
  FALSE_INFORMATION // Content spreading false or misleading information
  HATE_SPEECH // Content promoting hate against a group or individual
  VIOLENCE // Content depicting violence or encouraging harm
  COPYRIGHT_VIOLATION // Violation of intellectual property rights
  PRIVACY // Violation of privacy rights
  CHILD_EXPLOITATION // Content depicting or promoting child exploitation
  OTHER // For other reasons not listed above
}

model PostScore {
  id        String   @id @default(uuid()) @db.Uuid
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  score Float

  postId String @unique @map("post_id") @db.Uuid
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@map("post_scores")
}
